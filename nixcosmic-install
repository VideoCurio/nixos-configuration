#!/usr/bin/env bash

# Boot on a NixOS minimal ISO file, create a root password
# !IMPORTANT! Run this script as sudo
# It will create 3 partitions for '/boot', '/' and a 8Go swap
# OR with --crypt option, it will create a 512Mo boot and a LUKS partition.
# The encrypted LUKS partition will contain LVM partitions for '/' (100Go), '/home' and a 8Go swap.
#
# Usage:
#       nixcosmic-install [options] <disk_partition>
#
# Examples:
# nixcosmic-install /dev/nvme0n1               - Standard install on the first NVMe SSD.
# nixcosmic-install --crypt /dev/nvme0n1       - Full encrypted disk install on the first NVMe SSD.
# nixcosmic-install /dev/vda                   - Standard install on a QEMU disk.

set -eu

# Print help function
usage ()
{
  echo -e "
Usage: nixcosmic-install [options] <disk_partition>
  Where,
    disk_partition: Valid /dev path of a disk to install NixOS on.
    The default root partition size is set to 80G for full disk encryption option, use --root-size to change this.";

  cat << EOF

  Options:
     -h, --help         Print this message.
     --crypt            Full disk encryption with LVM+LUKS with separated root and /home partitions.
     --root-size SIZE   Set root partition size (e.g., 100G or 20%) - ONLY with --crypt option.
     --rpi4             Raspberry PI 4 installation (exclude --crypt option).
     -v, --verbose      Print more information.

  Examples:
    Full encrypted disk install on the first NVMe SSD (with /home partition):
      nixcosmic-install --crypt --root-size 120G /dev/nvme0n1
    Minimal disk install on the second HDD:
      nixcosmic-install /dev/sdb
    Minimal disk install on a QEMU/KVM virtual disk:
      nixcosmic-install /dev/vda
    Raspberry Pi 4 install:
      nix-shell -p git raspberrypi-eeprom
      nixcosmic-install --rpi4 /dev/mmcblk1
EOF
  exit;
}

do_dotfiles_install=1;
encrypt_disk=0;
root_size="80G";
rpi4_install=0;
verbose=0;
selected_locale="";
gpu_detected="";
install_gpu=0;
script_path="$(dirname "$0")"

# Function to validate root size format
validate_root_size() {
  local pattern="^[0-9]+([GMm]|%)$"
  if ! [[ "$1" =~ $pattern ]]; then
    printf "\e[31mInvalid root size format. Use 'SIZE[G|M|m]' or 'SIZE%%' (e.g., 100G, 15%% or 80m).\e[0m \n"
    exit 1
  fi
}

# Scripts arguments parse options
ARGS=$(getopt --longoptions="verbose,help,crypt,rpi4,root-size:" --name "$0" --options ":hv" -- "$@")
if [ $# -lt 1 ]; then
  usage
fi;

DISK_PART="${!#}"

eval set -- "$ARGS"

while true; do
  case "$1" in
    -v | --verbose)
      verbose=1
      shift
      ;;
    -h | --help)
      usage
      ;;
    --crypt)
      encrypt_disk=1
      shift
      ;;
    --rpi4)
      rpi4_install=1
      shift
      ;;
    --root-size)
      root_size="$2"
      validate_root_size "$root_size"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
  esac
done

if [ $rpi4_install -eq 1 ]; then
  # disk on RPI4 could not be modified
  encrypt_disk=0
fi

# Check disk path
if [ ! -e "$DISK_PART" ]; then
  printf "\e[31mDisk path is invalid! \e[0m \n"
  exit 2
fi

# check nixcosmic-sources files
nixcosmic_sources_path=$(nix-store --query --outputs $(which nixcosmic-install))
if [ ! -f "$nixcosmic_sources_path"/share/nixcosmic/configuration.nix ]; then
  printf "\e[31mconfiguration.nix file not found! \e[0m \n"
  exit 1
fi

if [ ! -f "$nixcosmic_sources_path"/share/nixcosmic/user-me.nix ]; then
  printf "\e[31muser-me.nix file not found! \e[0m \n"
  exit 1
fi

if [ ! -d "$nixcosmic_sources_path"/share/nixcosmic/modules/ ]; then
  printf "\e[31m modules directory not found! \e[0m \n"
  exit 1
fi

########### Choose your language:
locales=(
  "en_US.UTF-8"
  "en_GB.UTF-8"
  "fr_FR.UTF-8"
  "es_ES.UTF-8"
  "de_DE.UTF-8"
  "zh_CN.UTF-8"
  "ja_JP.UTF-8"
  "pt_PT.UTF-8"
  "ru_RU.UTF-8"
  "it_IT.UTF-8"
  "ko_KR.UTF-8"
  "ar_SA.UTF-8"
  "nl_NL.UTF-8"
  "pl_PL.UTF-8"
  "sv_SE.UTF-8"
  "tr_TR.UTF-8"
  "cs_CZ.UTF-8"
  "da_DK.UTF-8"
  "hu_HU.UTF-8"
  "no_NO.UTF-8"
  "he_IL.UTF-8"
)
locales_console=(
  "us"
  "gb"
  "fr"
  "es"
  "de"
  "zh"
  "ja"
  "pt"
  "ru"
  "it"
  "ko"
  "ar"
  "nl"
  "pl"
  "sv"
  "tr"
  "cs"
  "da"
  "hu"
  "no"
  "he"
)

# Print locales
echo "Choose your language in the list below:"
for i in "${!locales[@]}"; do
  echo "$((i+1))) ${locales[i]}"
done

read -r -p "Enter your choice (1-21): " lang_choice
if [ "$lang_choice" -ge 1 ] && [ "$lang_choice" -le ${#locales[@]} ]; then
  selected_locale="${locales[$((lang_choice-1))]}"
  # Update user language in configuration.nix:
  sed "s/defaultLocale = \".*/defaultLocale = \"${selected_locale}\";/g" -i "$script_path"/configuration.nix
  # Update console key map for cryptroot:
  selected_locale_console="${locales_console[$((lang_choice-1))]}"
  sed "s/defaultConsoleKeymap = \".*/defaultConsoleKeymap = \"${selected_locale_console}\";/g" -i "$script_path"/configuration.nix
  # Update xserver keyboard layout:
  sed "s/xkb\.layout = \".*/xkb.layout = \"${selected_locale_console}\";/g" -i "$script_path"/modules/services.nix
  sed "s/-layout [a-z]\{2\}/-layout ${selected_locale_console}/g" -i "$script_path"/modules/services.nix
  # TODO: 'loadkeys XX' to the currently selected layout ?
else
  echo "Invalid choice.Choose a number between 1 and ${#locales[@]}."
  exit 1
fi
# locale -a | grep "$selected_locale" ????
# echo "LANG=fr_FR.UTF-8" > ~/.config/locale.conf

########### TODO: keyboard layout

########### Choose a timezone:
read -r -p "Enter your time zone (Europe/Paris): " pc_timezone

# hostname check
if [ -z "$pc_timezone" ]; then
 pc_timezone="Europe/Paris"
fi
if ! [[ $pc_timezone =~ ^[a-zA-Z0-9/_+\-]+$ ]]; then
  printf "\e[31m Invalid time zone, it could only contain alphanumerical, '/', '-', '+' or '_' characters like 'America/New_York' or 'Etc/GMT+2'.\e[0m \n"
  exit 1
fi
# Update configuration.nix
sed "s/timeZone = \".*/timeZone = \"${pc_timezone//\//\\\/}\";/g" -i "$script_path"/configuration.nix

########### Choose a username:
read -r -p "Enter your username: " username

# username check
if [ -z "$username" ]; then
  printf "\e[31m username cannot be empty.\e[0m \n"
  exit 1
fi
if ! [[ $username =~ ^[[:alnum:]]+$ ]]; then
  printf "\e[31m Invalid username, it could only contain alphanumerical characters.\e[0m \n"
  exit 1
fi
# Update use-me.nix
sed "s/users\.users\..*/users.users.${username} = {/g" -i "$script_path"/user-me.nix

########### Choose a full name:
read -r -p "Enter your full name: " fullname

# fullname check
if [ -z "$fullname" ]; then
  fullname="Dwight K. Schrute"
  printf "You are now known as\e[32m %s\e[0m \n" "$fullname"
fi
if ! [[ $fullname =~ ^[[:alnum:][:space:].]+$ ]]; then
  printf "\e[31m Invalid full name, it could only contain alphanumerical, '.' or space characters.\e[0m \n"
  exit 1
fi
# Update use-me.nix
sed "s/description = \".*/description = \"${fullname}\";/g" -i "$script_path"/user-me.nix

########### Choose a hostname:
read -r -p "Choose your machine hostname (NixCOSMIC): " pc_hostname

# hostname check
if [ -z "$pc_hostname" ]; then
 pc_hostname="NixCOSMIC"
fi
if ! [[ $pc_hostname =~ ^[[:alnum:].]+$ ]]; then
  printf "\e[31m Invalid hostname, it could only contain alphanumerical or '.' characters.\e[0m \n"
  exit 1
fi
# Update configuration.nix
sed "s/networking\.hostName = \".*/networking.hostName = \"${pc_hostname}\";/g" -i "$script_path"/configuration.nix

########### platform settings:
if [ $rpi4_install -eq 1 ]; then
  # Update configuration.nix
  sed 's/nixcosmic\.platform\.rpi4\.enable = .*/nixcosmic.platform.rpi4.enable = lib.mkDefault true;/g' -i "$script_path"/configuration.nix
  sed 's/nixcosmic\.platform\.amd64\.enable = .*/nixcosmic.platform.amd64.enable = lib.mkDefault false;/g' -i "$script_path"/configuration.nix
  sed 's/nixcosmic\.filesystems\.luks\.enable = .*/nixcosmic.filesystems.luks.enable = lib.mkDefault false;/g' -i "$script_path"/configuration.nix
  sed 's/nixcosmic\.filesystems\.minimal\.enable = .*/nixcosmic.filesystems.minimal.enable = lib.mkDefault false;/g' -i "$script_path"/configuration.nix
  sed 's/nixcosmic\.bootefi\.enable = .*/nixcosmic.bootefi.enable = lib.mkDefault false;/g' -i "$script_path"/configuration.nix
else
  # Also update configuration.nix
  sed 's/nixcosmic\.platform\.rpi4\.enable = .*/nixcosmic.platform.rpi4.enable = lib.mkDefault false;/g' -i "$script_path"/configuration.nix
  sed 's/nixcosmic\.platform\.amd64\.enable = .*/nixcosmic.platform.amd64.enable = lib.mkDefault true;/g' -i "$script_path"/configuration.nix
  sed 's/nixcosmic\.bootefi\.enable = .*/nixcosmic.bootefi.enable = lib.mkDefault true;/g' -i "$script_path"/configuration.nix
fi

########### filesystems settings:
if [ $encrypt_disk -eq 1 ]; then
  # Update configuration.nix
  sed 's/nixcosmic\.filesystems\.luks\.enable = .*/nixcosmic.filesystems.luks.enable = lib.mkDefault true;/g' -i "$script_path"/configuration.nix
  sed 's/nixcosmic\.filesystems\.minimal\.enable = .*/nixcosmic.filesystems.minimal.enable = lib.mkDefault false;/g' -i "$script_path"/configuration.nix
else
  # Also update configuration.nix
  sed 's/nixcosmic\.filesystems\.luks\.enable = .*/nixcosmic.filesystems.luks.enable = lib.mkDefault false;/g' -i "$script_path"/configuration.nix
  sed 's/nixcosmic\.filesystems\.minimal\.enable = .*/nixcosmic.filesystems.minimal.enable = lib.mkDefault true;/g' -i "$script_path"/configuration.nix
fi

########### GPU:
gpu=$(lspci -nn | grep -i vga)
nb_gpu=$(lspci | grep -ci vga)

if (( nb_gpu >= 1 )); then
  if echo "$gpu" | grep -qi "amd"; then
    gpu_detected="amd"
    while true; do
      read -r -p "AMD GPU detected, would like to install it ? (y/n): " yn
      case $yn in
        [yY] ) install_gpu=1;
          break;;
        [nN] ) echo "Proceeding without installing GPU pilot...";
          break;;
        * ) echo "Invalid response";;
      esac
    done
  fi
  if echo "$gpu" | grep -qi "nvidia"; then
    gpu_detected="nvidia"
    while true; do
      read -r -p "Nvidia GPU detected, would like to install it ? (y/n): " yn
      case $yn in
        [yY] ) install_gpu=1;
          break;;
        [nN] ) echo "Proceeding without installing GPU pilot...";
          break;;
        * ) echo "Invalid response";;
      esac
    done
  fi

  if [[ "$install_gpu" -eq 1 && "$gpu_detected" == "amd" ]]; then
    echo "Enabling AMD GPU..."
    sed 's/nixcosmic\.hardware\.amdGpu\.enable = .*/nixcosmic.hardware.amdGpu.enable = lib.mkDefault true;/g' -i "$script_path"/configuration.nix
  elif [[ "$install_gpu" -eq 1 && "$gpu_detected" == "nvidia" ]]; then
    echo "Enabling Nvidia GPU..."
    sed 's/nixcosmic\.hardware\.nvidiaGpu\.enable = .*/nixcosmic.hardware.nvidiaGpu.enable = lib.mkDefault true;/g' -i "$script_path"/configuration.nix
  else
    echo "Disabling GPU..."
    sed 's/nixcosmic\.hardware\.amdGpu\.enable = .*/nixcosmic.hardware.amdGpu.enable = lib.mkDefault false;/g' -i "$script_path"/configuration.nix
    sed 's/nixcosmic\.hardware\.nvidiaGpu\.enable = .*/nixcosmic.hardware.nvidiaGpu.enable = lib.mkDefault false;/g' -i "$script_path"/configuration.nix
  fi
fi

# Test - debug parameters
if [ $verbose -eq 1 ]; then
  echo "path: $script_path"
  echo "--crypt: $encrypt_disk"
  echo "--rpi4: $rpi4_install"
  echo "--root-size: $root_size"
  echo "<disk_partition>: $DISK_PART"
  echo "selected_locale: $selected_locale"
  echo "username: $username"
  echo "hostname: $pc_hostname"
  echo "timezone: $pc_timezone"
  echo "GPU: $gpu_detected"
  echo "GPU install: $install_gpu"
fi

# This script must be run as root
if [ "$EUID" -ne 0 ]; then
  printf "\e[31mThis script MUST be run as root: sudo nixcosmic-install \e[0m \n" >&2
  exit 1
fi

# Check dependencies
available() { command -v "$1" >/dev/null; }

if ! available git; then
  printf "\e[31mgit command not found! \e[0m \n"
  exit 2
fi

# dotfiles install function
dotfiles-inst () {
  printf "\e[32m================================\e[0m \n"
  printf "\e[32m================================\e[0m \n"
  echo "Custom dotfiles installation..."
  git clone --bare https://github.com/VideoCurio/nixos-dotfiles.git /tmp/dotfiles/
  mkdir -p /mnt/etc/skel/
  git --git-dir=/tmp/dotfiles/ --work-tree=/mnt/etc/skel/ checkout || true
  rm -rf /tmp/dotfiles/
  # Iterate over each home user
  for dir in /mnt/home/*/; do
    if [[ -d "$dir" && "$dir" != "/mnt/home/lost+found/" ]]; then
      echo "Cloning dotfiles into: $dir"
      git clone --bare https://github.com/VideoCurio/nixos-dotfiles.git /tmp/dotfiles/
      git --git-dir=/tmp/dotfiles/ --work-tree="$dir" checkout || true
      chown -R 1000:100 "$dir" # Any way to predict OWNER at this stage ?
      rm -rf /tmp/dotfiles/
    fi
  done
  printf "\e[32mDotfiles installation done.\e[0m\n"
}

# Format disk function
format () {
  printf "\e[32m Formatting disk %s... \e[0m \n" "$DISK_PART"
  if [ $encrypt_disk -eq 1 ]; then
    echo "Disk will be fully encrypted..."
  fi

  # Check if disk exist
  if fdisk -l "$DISK_PART"; then
    DISK_PART1="$DISK_PART"1
    DISK_PART2="$DISK_PART"2
    DISK_PART3="$DISK_PART"3
    if [[ $DISK_PART =~ ^"/dev/nvme" ]]; then
      DISK_PART1="$DISK_PART"p1
      DISK_PART2="$DISK_PART"p2
      DISK_PART3="$DISK_PART"p3
    fi
  else
    printf "\e[31mDisk %s not found! \e[0m \n" "$DISK_PART"
    exit 2
  fi

  #parted -l
  if [ $verbose -eq 1 ]; then
    lsblk -lo NAME,SIZE,TYPE,MOUNTPOINTS,UUID
  fi

  printf "\e[32m================================\e[0m \n"
  printf "\e[32m================================\e[0m \n"
  echo "UEFI partitionning..."
  parted "$DISK_PART" -- mklabel gpt
  parted "$DISK_PART" -- mkpart ESP fat32 1MB 512MB
  parted "$DISK_PART" -- set 1 esp on
  if [ $encrypt_disk -eq 0 ]; then
    parted "$DISK_PART" -- mkpart root ext4 512MB -8GB
    parted "$DISK_PART" -- mkpart swap linux-swap -8GB 100%
  else
    parted "$DISK_PART" -- mkpart system 512MB 100%
  fi

  printf "\e[32m================================\e[0m \n"
  printf "\e[32m================================\e[0m \n"
  echo "Filesystem formatting..."
  mkfs.fat -F 32 -n boot "$DISK_PART1"
  if [ $encrypt_disk -eq 0 ]; then
    mkfs.ext4 -L nixos "$DISK_PART2"
    mkswap -L swap "$DISK_PART3"
  fi

  if [ $encrypt_disk -eq 1 ]; then
    printf "\e[32m================================\e[0m \n"
    printf "\e[32m================================\e[0m \n"
    echo "Creating encrypted partition..."
    cryptsetup luksFormat -q -y --label nixossystem  "$DISK_PART2"
    # open the encrypted partition and map it to /dev/mapper/cryptroot
    cryptsetup luksOpen "$DISK_PART2" cryptroot

    printf "\e[32m================================\e[0m \n"
    printf "\e[32m================================\e[0m \n"
    echo "Creating LVM volumes..."
    pvcreate /dev/mapper/cryptroot
    if [ $verbose -eq 1 ]; then
      pvdisplay
    fi
    # create a volume group inside
    vgcreate lvmroot /dev/mapper/cryptroot
    if [ $verbose -eq 1 ]; then
      vgdisplay
    fi
    # create the swap volume
    lvcreate --size 8G lvmroot --name swap
    # create the root volume
    lvcreate --size "$root_size" lvmroot --name root
    # create a home volume (100% of free disk)
    lvcreate -l 100%FREE lvmroot --name home
    if [ $verbose -eq 1 ]; then
      lvdisplay
    fi

    # Filesystem formatting
    mkfs.ext4 -L nixos /dev/mapper/lvmroot-root
    mkfs.ext4 -L home /dev/mapper/lvmroot-home
    mkswap -L swap /dev/mapper/lvmroot-swap
  fi
}

# Raspberry Pi 4 install
if [ $rpi4_install -eq 1 ]; then
  # Prepare an SD card
  # Download an SD card image from https://hydra.nixos.org/job/nixos/trunk-combined/nixos.sd_image.aarch64-linux
  # Unzip it with:
  # zstd -d nixos-image-sd-card-25.05.805977.88983d4b665f-aarch64-linux.img.zst
  # Burn it with Balena Etcher, Caligula or dd
  # sudo dd if=nixos-image-sd-card-25.05.805977.88983d4b665f-aarch64-linux.img of=/dev/sdb bs=10MB oflag=dsync status=progress
  # boot from the SD card, then as root:
  # nix-shell -p git raspberrypi-eeprom
  # cd /tmp
  # git clone https://github.com/VideoCurio/nixos-configuration
  # cd nixos-configuration/
  # nixcosmic-install --rpi4 /dev/mmcblk1
  printf "\e[32mRaspberry Pi 4 installation... \e[0m \n"
  # Updating firmware
  mount /dev/disk/by-label/FIRMWARE /mnt
  BOOTFS=/mnt rpi-eeprom-update -d -a

  cp "$script_path"/*.nix /etc/nixos/
  cp -r "$script_path"/modules/ /etc/nixos/

  nixos-rebuild boot
  printf "\e[32m Done... \e[0m \n"
  printf "\e[32m You can now reboot. \e[0m \n"
  exit 1
fi

while true; do
read -r -p "Partitioning disk $DISK_PART ? All data will be ERASED (y/n): " yn

case $yn in
  [yY] ) format;
    break;;
  [nN] ) echo "Proceeding without disk formatting...";
    break;;
  * ) echo "Invalid response";;
esac
done

if [ $verbose -eq 1 ]; then
  lsblk --fs
fi

printf "\e[32m================================\e[0m \n"
printf "\e[32m================================\e[0m \n"
echo "Mounting system..."
sleep 2s
if ! mountpoint -q /mnt; then
  mount /dev/disk/by-label/nixos /mnt
fi
mkdir -p /mnt/boot
if ! mountpoint -q /mnt/boot; then
  mount -o umask=077 /dev/disk/by-partlabel/ESP /mnt/boot
fi
if [[ $(swapon -s | wc -l) -eq 1 ]]; then
  swapon /dev/disk/by-label/swap
fi
if [ $encrypt_disk -eq 1 ]; then
  mkdir -p /mnt/home
  if ! mountpoint -q /mnt/home; then
    mount /dev/disk/by-label/home /mnt/home
  fi
fi

if [ $verbose -eq 1 ]; then
  fdisk -l "$DISK_PART"
  lsblk -lo NAME,SIZE,TYPE,MOUNTPOINTS,PARTLABEL,UUID
fi

echo "Create basic configuration:"
nixos-generate-config --root /mnt --no-filesystems

printf "\e[32m================================\e[0m \n"
printf "\e[32m================================\e[0m \n"
echo "Copying configurations files..."

cp "$script_path"/*.nix /mnt/etc/nixos/
cp -r "$script_path"/modules/ /mnt/etc/nixos/

while true; do
read -r -p "Proceed with installation ? (y/n): " yn

case $yn in
  [yY] ) echo "nixos-install";
    nixos-install --no-root-passwd
    if [ $do_dotfiles_install -eq 1 ]; then
      dotfiles-inst
    fi
    printf "\e[32m Done... \e[0m \n"
    printf "\e[32m You can now reboot. \e[0m \n"
    break;;
  [nN] ) echo "Exiting...";
    exit;;
  * ) echo "Invalid response";;
esac
done
